/* eslint-disable no-restricted-globals */

// This service worker is based on Workbox (precache + runtime routes).
// Changes made:
// - Ensure we only attempt to cache GET requests (Cache API does not support POST).
// - Defensive checks / try-catch to avoid uncaught Cache.put errors if a route accidentally receives a non-GET.
// - Keep a small defensive fetch listener so unexpected non-GET requests do not cause exceptions.
// - Explicitly narrow the runtime image caching predicate to GET + same-origin + .png
// - No attempt to cache POST responses. If you need to "cache" POST results, use IndexedDB (not Cache API).

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in the service worker file,
// even if you decide not to use precaching. See CRA PWA docs.
precacheAndRoute(self.__WB_MANIFEST || []);

// App shell-style routing for navigation requests.
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }) => {
    // Only handle navigation requests.
    if (request.mode !== 'navigate') return false;
    // Skip internal /__ resources
    if (url.pathname.startsWith('/_')) return false;
    // If this looks like a URL for a resource (file extension), skip.
    if (url.pathname.match(fileExtensionRegexp)) return false;
    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// Runtime caching for same-origin .png images.
// IMPORTANT: require request.method === 'GET' to avoid Cache.put errors for POSTs.
registerRoute(
  ({ request, url }) => {
    try {
      return request && request.method === 'GET' &&
             url && url.origin === self.location.origin &&
             url.pathname.endsWith('.png');
    } catch (err) {
      // Defensive: if anything odd happens, do not match so we don't attempt to cache.
      return false;
    }
  },
  new StaleWhileRevalidate({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

// Defensive fetch handler: ensure we don't attempt to cache/put non-GET requests anywhere.
// This will not interfere with Workbox routes because we simply return early for non-GETs.
// Also add a very small guard around cache operations to avoid uncaught exceptions.
self.addEventListener('fetch', (event) => {
  // If it's not a GET request, don't allow any custom caching logic below to run.
  // This ensures no code ever calls caches.put on a POST/PUT/DELETE request.
  if (!event.request || event.request.method !== 'GET') {
    return;
  }
  // For GETs, let Workbox handle routes. We intentionally do not intercept here.
});

// Optional: you can instrument a small global error handler to avoid uncaught promise rejections
self.addEventListener('unhandledrejection', (event) => {
  // Prevent noisy console logs from propagating to clients; log safely
  try {
    // Keep this minimal; do not block or throw
    console.warn('SW unhandledrejection:', event.reason);
  } catch (e) { /* ignore */ }
});

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});